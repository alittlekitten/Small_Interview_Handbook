## 📣 Table

- [THIS](#-this)
- [바인딩 규칙](#-바인딩-규칙)
- [기본 바인딩](#-기본-바인딩)
- [암시적 바인딩](#-암시적-바인딩)
- [명시적 바인딩](#-명시적-바인딩)
- [new 바인딩](#-new-바인딩)

---

### 👉 THIS
- 일반적인 객체지향 언어와는 다르게 자바스크립트의 함수는 일급 객체이기 때문에 **변수나 데이터에 저장**할 수 있고, **함수의 인수로 전달**할 수 있고, **함수의 반환값**으로 사용이 가능합니다.
- 그래서 함수는 단독으로 실행될 수 있고, 객체의 메서드로서 실행될 수 있고, 다른 두 객체에서 동일한 함수가 실행될 수도 있습니다.
- 자바스크립트에서 모든 함수는 this를 가지고 있습니다. 그리고 함수가 호출되면 this가 가리키는 객체가 결정됩니다. (이것을 바인딩된다고 말합니다)

<br />

### 👉 바인딩 규칙
- 바인딩은 `기본 바인딩`, `암시적 바인딩`, `명시적 바인딩`, `new 바인딩`이 존재합니다.
- 각각의 바인딩에는 우선순위가 존재합니다.
- `기본 바인딩` -> `암시적 바인딩` -> `명시적 바인딩` -> `new 바인딩` 순으로 오른쪽으로 갈수록 우선순위가 높습니다.

<br />

### 👉 기본 바인딩
- 함수를 단독실행하게 되면 this는 기본적으로 전역 객체에 바인딩됩니다.
- 브라우저에서는 `window`에 바인딩되는데, 엄격모드인 use strict상태에서는 기본 바인딩에서 제외가 되서 `undefined`가 할당됩니다.
- node환경에서는 기본적으로 `global`이 this에 할당됩니다.
- 그런데 전역에서 호출하게 되는 경우 실제로 console.log를 이용해서 찍어보면 빈 객체가 나오는데, 해당 빈 객체는 module 객체의 `exports`와 동일한 객체입니다.

<br />

### 👉 암시적 바인딩
- 객체 안에서 메서드로 사용되는 경우 this는 해당 객체를 가리키게 되고, 이것을 암시적 바인딩이라고 부릅니다.
- 점(.) 연산이나 대괄호 연산으로 객체의 프로퍼티에 접근하는 경우 참조타입 형태로 반환합니다.
- 참조타입은 프로퍼티의 값(name)과 프로퍼티를 가진 객체(base), strict 여부(strict)를 같이 가지고 있습니다. (base, name, strict)
- 이걸 통해서 참조 타입에 있는 객체를 찾아서 this 바인딩을 하게 됩니다.
- 하지만 다른 방식으로 해당 프로퍼티에 접근하거나 전달하게 되는 경우 참조타입이 아닌 해당 프로퍼티의 (참조)값만 전달됩니다.
- 따라서 점 연산을 통해 접근한 프로퍼티는 바로 함수로 호출하지 않으면 암시적 바인딩이 이루어지지 않습니다.
- 매개변수로 전달된 콜백함수의 참조 역시 동일한 이유로 바인딩이 이루어지지 않고 함수로 단독 호출한것과 같은 동작을 하게 됩니다.
- 이런 this 소실 문제를 해결하기 위해 등장한 것이 명시적 바인딩인 `call`, `apply`, `bind`입니다.

<br />

### 👉 명시적 바인딩
- Call
  - func.call(thisArg[, arg1[, arg2[, ...]]]) 형태로 사용합니다.
  - thisArg 위치에 원하는 this를 넣으면 해당 this가 함수 혹은 메서드에 할당됩니다.
  - arg 위치에 매개변수를 넣어서 전달할 수 있습니다.
  - this를 바꾸고 해당 함수를 실행합니다.
- Apply
  - func.apply(thisArg, [argsArray]) 형태로 사용합니다.
  - thisArg 위치에 원하는 this를 넣으면 해당 this가 함수 혹은 메서드에 할당됩니다.
  - Call과 다른 점은 배열 형태로 매개변수를 전달합니다. 그 외의 다른 동작은 Call과 동일합니다.
  - this를 바꾸고 해당 함수를 실행합니다.
- Bind
  - func.bind(thisArg[, arg1[, arg2[, ...]]]) 형태로 사용합니다.
  - thisArg 위치에 원하는 this를 넣으면 해당 this가 함수 혹은 메서드에 할당됩니다.
  - Call, Apply와 다른 점은 this를 바꾸고 해당 함수를 실행하는 것이 아닌 생성만 하게 됩니다.
  - 이외의 다른 동작은 Call, Apply와 동일합니다.

<br />

### 👉 new 바인딩
  - new 연산자를 통해 함수를 호출하면 해당 함수는 생성자 함수 역할을 수행할 수 있게 됩니다.
  - this는 새롭게 생성한 객체를 바인딩합니다.
